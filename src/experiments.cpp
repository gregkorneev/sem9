#include "hanoi.h"
#include <iostream>
#include <fstream>
#include <filesystem>
#include <iomanip>
#include <cmath>

using long_long = long long;
namespace fs = std::filesystem;

/*
 * Проведение серии экспериментов:
 * Для N = 1..maxN:
 *  - вычисление оптимального количества ходов
 *  - запуск рекурсивного полного перебора (классического алгоритма)
 *  - измерение времени
 *  - сохранение результатов в CSV
 *  - формирование отчета в Markdown
 */

void runExperiments(int maxN) {
    if (maxN <= 0) {
        std::cout << "maxN должно быть положительным.\n";
        return;
    }

    // Создание директорий
    try {
        fs::create_directories("data/csv");
    } catch (...) {
        std::cout << "Не удалось создать папки data/csv.\n";
        return;
    }

    const std::string csvPath = "data/csv/hanoi_results.csv";
    const std::string mdPath  = "data/hanoi_report.md";

    std::ofstream csv(csvPath);
    if (!csv.is_open()) {
        std::cout << "Не удалось открыть файл " << csvPath << " для записи.\n";
        return;
    }

    csv << "N,Ходы (перебор),Теория 2^N-1,Время (мс)\n";

    std::cout << "\n=== Эксперименты: задача Ханойских башен ===\n";
    std::cout << "Результаты будут сохранены в " << csvPath << "\n\n";
    std::cout << "N\tХоды\tТеория\tВремя, мс\n";
    std::cout << "---------------------------------------------\n";

    std::cout << std::fixed << std::setprecision(6);

    for (int n = 1; n <= maxN; ++n) {
        long_long moves = 0;
        double ms = 0.0;

        // Запуск рекурсивного перебора (единственно возможного оптимального решения)
        solveHanoi(n, moves, ms);

        long_long theory = (1LL << n) - 1; // 2^N - 1

        std::cout << n << "\t"
                  << moves << "\t"
                  << theory << "\t"
                  << ms << "\n";

        csv << n << ","
            << moves << ","
            << theory << ","
            << std::setprecision(10) << ms << "\n";
    }

    csv.close();

    // ----- ОТЧЁТ -----
    std::ofstream md(mdPath);
    if (!md.is_open()) {
        std::cout << "\nНе удалось создать файл " << mdPath << "\n";
        return;
    }

    md << "# Отчёт по задаче Ханойских башен\n\n";
    md << "Данные экспериментов сохранены в `data/csv/hanoi_results.csv`.\n\n";

    md << "## 1. Полный перебор\n";
    md << "Используется классический рекурсивный алгоритм решения задачи, "
          "который перебирает **все необходимые ходы** для оптимального решения.\n\n";

    md << "Минимальное число ходов для Ханойских башен с N дисками:\n";
    md << "\\[\n2^N - 1\n\\]\n";
    md << "Эксперимент подтверждает полное совпадение теоретической и фактической оценки.\n\n";

    md << "## 2. Вычислительная сложность\n";
    md << "Классический алгоритм имеет экспоненциальную сложность:\n";
    md << "\\[\nO(2^N)\n\\]\n";
    md << "Каждый дополнительный диск удваивает объём работы.\n\n";

    md << "## 3. Практический предел перебора\n";
    md << "Тестирование показывает, что уже при N≈20 общее число операций превышает миллион, "
          "а при N≥30 — миллиард. Это делает полный перебор непрактичным для больших N.\n\n";

    md << "## 4. Лучший алгоритм\n";
    md << "Хотя задача допускает единственный оптимальный набор ходов, можно применять "
          "**итеративный алгоритм решения Ханойских башен**, который избегает рекурсии.\n\n";

    md << "Итеративный алгоритм:\n";
    md << "- генерирует последовательность ходов путём анализа чётности дисков;\n";
    md << "- использует правило «младший диск двигается через каждые 1 ход», "
          "следующий — через 2 хода, третий — через 4 хода и т.д.;\n";
    md << "- позволяет избежать накладных расходов рекурсивного стека.\n\n";

    md << "При этом **асимптотическая сложность остаётся той же**:\n";
    md << "\\[\nO(2^N)\n\\]\n";
    md << "но практическая производительность лучше за счёт отсутствия рекурсивных вызовов.\n\n";

    md << "## 5. Итог\n";
    md << "- Реализован полный перебор оптимального решения.\n";
    md << "- Определены временные и вычислительные характеристики.\n";
    md << "- Показано экспоненциальное ограничение перебора.\n";
    md << "- Предложена улучшенная версия алгоритма (итеративная), сохраняющая сложность но уменьшающая константный фактор.\n";

    md.close();

    std::cout << "\nОтчёт сохранён в: " << mdPath << "\n";
}
